## CPU高速缓存和指令重排
问题：
1、缓存中的数据和主内存的数据并不是实时同步的，各个CPU间缓存的数据也不是一致的。会导致在同一时间点，各CPU看到同一内存的数据可能会不一致。  
2、指令重排在单CPU下可以正常执行，但是在多CPU下，不能确保正确执行。
解决：内存屏障
1、写内存屏障：（store barrier）强制写入主内存。
2、读内存屏障：（load barrier）强制从主内存读取数据。

## java锁
### 锁
#### 悲观锁
假定发生并发冲突，同步所有对数据的相关操作，从读数据就开始上锁。
#### 乐观锁
假定没有冲突，在修改数据时如果发现数据和之前获取的不一致，则读最新数据，修改后重试修改。
##### 自旋锁
为了不放弃CPU执行时间，循环的使用CAS技术对数据尝试进行更新直至成功。
#### 独享锁（写）
给资源上写锁（单写）
#### 共享锁（读）
读取数据不加锁（多读）
#### 可重入锁、不可重入锁
同一线程可以重复获取相同的锁。
#### 公平锁、非公平锁（Lock）
争抢锁的顺序，如果先来后到则为公平，都是随机则为非公平。


###同步关键字synchronized
特性：可重入、独享、悲观锁  
范围：类、对象、锁消除、锁粗化
注：同步关键字，不仅实现同步，还能保证可见性。
**ObjectMonitor**对象监视器。
#### 轻量级锁、重量级锁
对象在jvm中存储有一个状态位标识，01-未锁定 00-轻量级 10-重量级 11-被回收。当一个线程获取某个对象的锁时，标识会变为轻量级锁，这个时候另一个线程也去获取这个对象的锁，通过CAS
机制进行自旋到一定次数，对象的锁就编程重量级锁。同时未获取锁的线程会进入这个对象的对应的monitor对象中等待争取锁。
#### 偏向锁
当只有一个线程获取某个对象的锁，则会使用偏向锁。由一个偏向状态位和线程信息组成。为了减少获取释放锁的消耗。本质是无锁。

## Queue